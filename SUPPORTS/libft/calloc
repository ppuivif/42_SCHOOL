void	*ft_calloc(size_t nmemb, size_t size)

->The  calloc()  function  allocates memory for an array of nmemb elements of size bytes each and returns a pointer to the allocated memory.  The memory is set to zero.
If nmemb or size is  0, then  calloc()  returns  either  NULL, or a unique pointer value that can later be successfully passed to free().
If the multiplication of nmemb and size would result  in  integer  overflow, then  calloc() returns an error. By contrast, an integer overflow would not be detected in the following call to malloc(), with the result that an incorrectly sized block of memory would be allocated:

           malloc(nmemb * size);
      
->The malloc() and calloc() functions return a pointer to the allocated memory, which is suitably aligned for any built-in type.  On error, these functions return NULL.  NULL may  also  be  returned  by  a  successful call to malloc() with a size of zero, or by a successful call to calloc() with nmemb or size equal to zero.

->calloc(), malloc(), realloc(), and reallocarray() can fail with the following error:

       ENOMEM Out of memory.  Possibly, the application hit the RLIMIT_AS  or  RLIMIT_DATA  limit  described in getrlimit(2).
              
!!!

#include "libft.h"

void	*ft_calloc(size_t nmemb, size_t size)
{
	char	*str;
	size_t	i;
	size_t	j;

	i = 0;
	j = nmemb * size;
	if (!size || !nmemb)
		return (malloc(1));
	if (j > 2147483646 || (size > 65535 && nmemb > 65535))
		return (NULL);
	str = (char *)malloc(j);
	if (str)
	{
		while (i < j)
		{
			str[i] = '\0';
			i++;
		}
		return ((void *) str);
	}
	return (NULL);
}

#include <stdlib.h>
#include <stdio.h>

int	main(int argc, char **argv)
{
	if (argc == 3)
	{
		printf("real_function return :\t%p\n",
			calloc(atoi(argv[1]), atoi(argv[2])));
	}
	if (argc == 4)
	{
		printf("ft_function return :\t%p\n",
			ft_calloc(atoi(argv[1]), atoi(argv[2])));
	}
	return (0);
}
